import{E as D,d as k,v,T,f as I,a as H,C as M,R as O,b as L,I as N,g as j,c as U,e as A,l as G,h as z,w as q,i as J}from"./index-DvPXTXTc.js";class K extends D{constructor(){super(...arguments),this.chars=Object.create(null),this.lineHeight=0,this.fontFamily="",this.fontMetrics={fontSize:0,ascent:0,descent:0},this.baseLineOffset=0,this.distanceField={type:"none",range:0},this.pages=[],this.applyFillAsTint=!0,this.baseMeasurementFontSize=100,this.baseRenderedFontSize=100}get font(){return k(v,"BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."),this.fontFamily}get pageTextures(){return k(v,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}get size(){return k(v,"BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."),this.fontMetrics.fontSize}get distanceFieldRange(){return k(v,"BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."),this.distanceField.range}get distanceFieldType(){return k(v,"BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."),this.distanceField.type}destroy(t=!1){this.emit("destroy",this),this.removeAllListeners();for(const e in this.chars)this.chars[e].texture?.destroy();this.chars=null,t&&(this.pages.forEach(e=>e.texture.destroy(!0)),this.pages=null)}}const $=class Y extends K{constructor(t){super(),this.resolution=1,this.pages=[],this._padding=0,this._measureCache=Object.create(null),this._currentChars=[],this._currentX=0,this._currentY=0,this._currentMaxCharHeight=0,this._currentPageIndex=-1,this._skipKerning=!1;const e={...Y.defaultOptions,...t};this._textureSize=e.textureSize,this._mipmap=e.mipmap;const i=e.style.clone();e.overrideFill&&(i._fill.color=16777215,i._fill.alpha=1,i._fill.texture=T.WHITE,i._fill.fill=null),this.applyFillAsTint=e.overrideFill;const s=i.fontSize;i.fontSize=this.baseMeasurementFontSize;const n=I(i);e.overrideSize?i._stroke&&(i._stroke.width*=this.baseRenderedFontSize/s):i.fontSize=this.baseRenderedFontSize=s,this._style=i,this._skipKerning=e.skipKerning??!1,this.resolution=e.resolution??1,this._padding=e.padding??4,e.textureStyle&&(this._textureStyle=e.textureStyle instanceof H?e.textureStyle:new H(e.textureStyle)),this.fontMetrics=M.measureFont(n),this.lineHeight=i.lineHeight||this.fontMetrics.fontSize||i.fontSize}ensureCharacters(t){const e=M.graphemeSegmenter(t).filter(g=>!this._currentChars.includes(g)).filter((g,l,c)=>c.indexOf(g)===l);if(!e.length)return;this._currentChars=[...this._currentChars,...e];let i;this._currentPageIndex===-1?i=this._nextPage():i=this.pages[this._currentPageIndex];let{canvas:s,context:n}=i.canvasAndContext,a=i.texture.source;const r=this._style;let o=this._currentX,u=this._currentY,h=this._currentMaxCharHeight;const p=this.baseRenderedFontSize/this.baseMeasurementFontSize,w=this._padding*p;let x=!1;const S=s.width/this.resolution,m=s.height/this.resolution;for(let g=0;g<e.length;g++){const l=e[g],c=M.measureText(l,r,s,!1);c.lineHeight=c.height;const f=c.width*p,y=Math.ceil((r.fontStyle==="italic"?2:1)*f),W=c.height*p,b=y+w*2,F=W+w*2;if(x=!1,l!==`
`&&l!=="\r"&&l!=="	"&&l!==" "&&(x=!0,h=Math.ceil(Math.max(F,h))),o+b>S&&(u+=h,h=F,o=0,u+h>m)){a.update();const C=this._nextPage();s=C.canvasAndContext.canvas,n=C.canvasAndContext.context,a=C.texture.source,o=0,u=0,h=0}const _=f/p-(r.dropShadow?.distance??0)-(r._stroke?.width??0);if(this.chars[l]={id:l.codePointAt(0),xOffset:-this._padding,yOffset:-this._padding,xAdvance:_,kerning:{}},x){this._drawGlyph(n,c,o+w,u+w,p,r);const C=a.width*p,P=a.height*p,X=new O(o/C*a.width,u/P*a.height,b/C*a.width,F/P*a.height);this.chars[l].texture=new T({source:a,frame:X}),o+=Math.ceil(b)}}a.update(),this._currentX=o,this._currentY=u,this._currentMaxCharHeight=h,this._skipKerning&&this._applyKerning(e,n)}get pageTextures(){return k(v,"BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."),this.pages}_applyKerning(t,e){const i=this._measureCache;for(let s=0;s<t.length;s++){const n=t[s];for(let a=0;a<this._currentChars.length;a++){const r=this._currentChars[a];let o=i[n];o||(o=i[n]=e.measureText(n).width);let u=i[r];u||(u=i[r]=e.measureText(r).width);let h=e.measureText(n+r).width,p=h-(o+u);p&&(this.chars[n].kerning[r]=p),h=e.measureText(n+r).width,p=h-(o+u),p&&(this.chars[r].kerning[n]=p)}}}_nextPage(){this._currentPageIndex++;const t=this.resolution,e=L.getOptimalCanvasAndContext(this._textureSize,this._textureSize,t);this._setupContext(e.context,this._style,t);const i=t*(this.baseRenderedFontSize/this.baseMeasurementFontSize),s=new T({source:new N({resource:e.canvas,resolution:i,alphaMode:"premultiply-alpha-on-upload",autoGenerateMipmaps:this._mipmap})});this._textureStyle&&(s.source.style=this._textureStyle);const n={canvasAndContext:e,texture:s};return this.pages[this._currentPageIndex]=n,n}_setupContext(t,e,i){e.fontSize=this.baseRenderedFontSize,t.scale(i,i),t.font=I(e),e.fontSize=this.baseMeasurementFontSize,t.textBaseline=e.textBaseline;const s=e._stroke,n=s?.width??0;if(s&&(t.lineWidth=n,t.lineJoin=s.join,t.miterLimit=s.miterLimit,t.strokeStyle=j(s,t)),e._fill&&(t.fillStyle=j(e._fill,t)),e.dropShadow){const a=e.dropShadow,r=U.shared.setValue(a.color).toArray(),o=a.blur*i,u=a.distance*i;t.shadowColor=`rgba(${r[0]*255},${r[1]*255},${r[2]*255},${a.alpha})`,t.shadowBlur=o,t.shadowOffsetX=Math.cos(a.angle)*u,t.shadowOffsetY=Math.sin(a.angle)*u}else t.shadowColor="black",t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0}_drawGlyph(t,e,i,s,n,a){const r=e.text,o=e.fontProperties,h=(a._stroke?.width??0)*n,p=i+h/2,w=s-h/2,x=o.descent*n,S=e.lineHeight*n;let m=!1;a.stroke&&h&&(m=!0,t.strokeText(r,p,w+S-x));const{shadowBlur:g,shadowOffsetX:l,shadowOffsetY:c}=t;a._fill&&(m&&(t.shadowBlur=0,t.shadowOffsetX=0,t.shadowOffsetY=0),t.fillText(r,p,w+S-x)),m&&(t.shadowBlur=g,t.shadowOffsetX=l,t.shadowOffsetY=c)}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{canvasAndContext:e,texture:i}=this.pages[t];L.returnCanvasAndContext(e),i.destroy(!0)}this.pages=null}};$.defaultOptions={textureSize:512,style:new A,mipmap:!0};let R=$;function Z(d,t,e,i){const s={width:0,height:0,offsetY:0,scale:t.fontSize/e.baseMeasurementFontSize,lines:[{width:0,charPositions:[],spaceWidth:0,spacesIndex:[],chars:[]}]};s.offsetY=e.baseLineOffset;let n=s.lines[0],a=null,r=!0;const o={width:0,start:0,index:0,positions:[],chars:[]},u=e.baseMeasurementFontSize/t.fontSize,h=t.letterSpacing*u,p=t.wordWrapWidth*u,w=t.lineHeight?t.lineHeight*u:e.lineHeight,x=t.wordWrap&&t.breakWords,S=l=>{const c=n.width;for(let f=0;f<o.index;f++){const y=l.positions[f];n.chars.push(l.chars[f]),n.charPositions.push(y+c)}n.width+=l.width,r=!1,o.width=0,o.index=0,o.chars.length=0},m=()=>{let l=n.chars.length-1;if(i){let c=n.chars[l];for(;c===" ";)n.width-=e.chars[c].xAdvance,c=n.chars[--l]}s.width=Math.max(s.width,n.width),n={width:0,charPositions:[],chars:[],spaceWidth:0,spacesIndex:[]},r=!0,s.lines.push(n),s.height+=w},g=l=>l-h>p;for(let l=0;l<d.length+1;l++){let c;const f=l===d.length;f||(c=d[l]);const y=e.chars[c]||e.chars[" "];if(/(?:\s)/.test(c)||c==="\r"||c===`
`||f){if(!r&&t.wordWrap&&g(n.width+o.width)?(m(),S(o),f||n.charPositions.push(0)):(o.start=n.width,S(o),f||n.charPositions.push(0)),c==="\r"||c===`
`)m();else if(!f){const _=y.xAdvance+(y.kerning[a]||0)+h;n.width+=_,n.spaceWidth=_,n.spacesIndex.push(n.charPositions.length),n.chars.push(c)}}else{const F=y.kerning[a]||0,_=y.xAdvance+F+h;x&&g(n.width+o.width+_)&&(S(o),m()),o.positions[o.index++]=o.width+F,o.chars.push(c),o.width+=_}a=c}return m(),t.align==="center"?V(s):t.align==="right"?Q(s):t.align==="justify"&&ee(s),s}function V(d){for(let t=0;t<d.lines.length;t++){const e=d.lines[t],i=d.width/2-e.width/2;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=i}}function Q(d){for(let t=0;t<d.lines.length;t++){const e=d.lines[t],i=d.width-e.width;for(let s=0;s<e.charPositions.length;s++)e.charPositions[s]+=i}}function ee(d){const t=d.width;for(let e=0;e<d.lines.length;e++){const i=d.lines[e];let s=0,n=i.spacesIndex[s++],a=0;const r=i.spacesIndex.length,u=(t-i.width)/r;for(let h=0;h<i.charPositions.length;h++)h===n&&(n=i.spacesIndex[s++],a+=u),i.charPositions[h]+=a}}function te(d){if(d==="")return[];typeof d=="string"&&(d=[d]);const t=[];for(let e=0,i=d.length;e<i;e++){const s=d[e];if(Array.isArray(s)){if(s.length!==2)throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${s.length}.`);if(s[0].length===0||s[1].length===0)throw new Error("[BitmapFont]: Invalid character delimiter.");const n=s[0].charCodeAt(0),a=s[1].charCodeAt(0);if(a<n)throw new Error("[BitmapFont]: Invalid character range.");for(let r=n,o=a;r<=o;r++)t.push(String.fromCharCode(r))}else t.push(...Array.from(s))}if(t.length===0)throw new Error("[BitmapFont]: Empty set when resolving characters.");return t}let B=0;class se{constructor(){this.ALPHA=[["a","z"],["A","Z"]," "],this.NUMERIC=[["0","9"]],this.ALPHANUMERIC=[["a","z"],["A","Z"],["0","9"]," "],this.ASCII=[[" ","~"]],this.defaultOptions={chars:this.ALPHANUMERIC,resolution:1,padding:4,skipKerning:!1,textureStyle:null},this.measureCache=G(1e3)}getFont(t,e){let i=`${e.fontFamily}-bitmap`,s=!0;if(e._fill.fill&&!e._stroke?(i+=e._fill.fill.styleKey,s=!1):(e._stroke||e.dropShadow)&&(i=`${e.styleKey}-bitmap`,s=!1),!z.has(i)){const a=Object.create(e);a._lineHeight=0;const r=new R({style:a,overrideFill:s,overrideSize:!0,...this.defaultOptions});B++,B>50&&q("BitmapText",`You have dynamically created ${B} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``),r.once("destroy",()=>{B--,z.remove(i)}),z.set(i,r)}const n=z.get(i);return n.ensureCharacters?.(t),n}getLayout(t,e,i=!0){const s=this.getFont(t,e),n=`${t}-${e.styleKey}-${i}`;if(this.measureCache.has(n))return this.measureCache.get(n);const a=M.graphemeSegmenter(t),r=Z(a,e,s,i);return this.measureCache.set(n,r),r}measureText(t,e,i=!0){return this.getLayout(t,e,i)}install(...t){let e=t[0];typeof e=="string"&&(e={name:e,style:t[1],chars:t[2]?.chars,resolution:t[2]?.resolution,padding:t[2]?.padding,skipKerning:t[2]?.skipKerning},k(v,"BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));const i=e?.name;if(!i)throw new Error("[BitmapFontManager] Property `name` is required.");e={...this.defaultOptions,...e};const s=e.style,n=s instanceof A?s:new A(s),a=e.dynamicFill??this._canUseTintForStyle(n),r=new R({style:n,overrideFill:a,skipKerning:e.skipKerning,padding:e.padding,resolution:e.resolution,overrideSize:!1,textureStyle:e.textureStyle}),o=te(e.chars);return r.ensureCharacters(o.join("")),z.set(`${i}-bitmap`,r),r.once("destroy",()=>z.remove(`${i}-bitmap`)),r}uninstall(t){const e=`${t}-bitmap`,i=z.get(e);i&&i.destroy()}_canUseTintForStyle(t){return!t._stroke&&(!t.dropShadow||t.dropShadow.color===0)&&!t._fill.fill&&t._fill.color===16777215}}const E=new se;class ne extends K{constructor(t,e){super();const{textures:i,data:s}=t;Object.keys(s.pages).forEach(n=>{const a=s.pages[parseInt(n,10)],r=i[a.id];this.pages.push({texture:r})}),Object.keys(s.chars).forEach(n=>{const a=s.chars[n],{frame:r,source:o,rotate:u}=i[a.page],h=J.transformRectCoords(a,r,u,new O),p=new T({frame:h,orig:new O(0,0,a.width,a.height),source:o,rotate:u});this.chars[n]={id:n.codePointAt(0),xOffset:a.xOffset,yOffset:a.yOffset,xAdvance:a.xAdvance,kerning:a.kerning??{},texture:p}}),this.baseRenderedFontSize=s.fontSize,this.baseMeasurementFontSize=s.fontSize,this.fontMetrics={ascent:0,descent:0,fontSize:s.fontSize},this.baseLineOffset=s.baseLineOffset,this.lineHeight=s.lineHeight,this.fontFamily=s.fontFamily,this.distanceField=s.distanceField??{type:"none",range:0},this.url=e}destroy(){super.destroy();for(let t=0;t<this.pages.length;t++){const{texture:e}=this.pages[t];e.destroy(!0)}this.pages=null}static install(t){E.install(t)}static uninstall(t){E.uninstall(t)}}export{ne as BitmapFont};
